{
  "language": "Solidity",
  "sources": {
    "contracts/Trust.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.14;\n\nerror SEND_MORE_FUNDS();\nerror TRANSFER_FAILED();\nerror ONLY_ONWER_CAN_CALL_FUNCTION();\nerror JOB_NOT_DONE();\nerror JOB_DONE();\nerror STILL_HAVE_TIME();\n\ncontract Trust {\n    // address of owner\n    address public immutable owner;\n\n    // percentage of profit he/she is willing to give\n    uint256 public immutable percentage;\n\n    // number of gigs owner will give commionsion/cut to bielevers\n    uint256 public immutable gigCount;\n\n    // Arrays of supporters/Believers\n    address[] public believers;\n\n    // count of projects done\n    uint256 public projectCount;\n\n    // address of the trustFactory contract\n    address payable public platformAddress;\n\n    // contract creation time\n    uint256 public contractCreationTime;\n\n    constructor(\n        uint256 _percentage,\n        address _owner,\n        uint256 _gigCount,\n        address _platformAddress\n    ) {\n        // Store the address of the deployer as a payable address.\n        // When we withdraw funds, we'll withdraw here.\n        owner = payable(_owner);\n        percentage = _percentage;\n        gigCount = _gigCount;\n        platformAddress = payable(_platformAddress);\n\n        contractCreationTime = block.timestamp;\n    }\n\n    // adding senior / Believer to the believers array\n    function AddBeliever() public payable {\n        if (msg.value < 1e17) {\n            // 1,00,000,000,000,000,000 = 1e17 = 1 * 10 * 17 = 0.1 Eth\n            revert SEND_MORE_FUNDS();\n        }\n        believers.push(msg.sender);\n    }\n\n    // give money to believers and owner\n    function gettingPaid(uint256 _amount) public payable {\n        if (_amount < 1e14 || msg.value < _amount) {\n            // 1,00,000,000,000,000 = 1e14 = 1 * 10 ** 14 =  0.0001 ETH\n            revert SEND_MORE_FUNDS();\n        }\n        projectCount++;\n        // sending money to believers\n        uint256 believersAmount = (msg.value * percentage) / 100;\n        if (believers.length >= 1) {\n            for (uint256 i = 0; i < believers.length; i++) {\n                (bool success, ) = believers[i].call{\n                    value: believersAmount / believers.length\n                }(\"\");\n                // require(success, \"Transfer failed\");\n                if (!success) {\n                    revert TRANSFER_FAILED();\n                }\n            }\n        }\n        // sending money to contract owner\n        (bool success1, ) = owner.call{value: msg.value - believersAmount}(\"\");\n        if (!success1) {\n            revert TRANSFER_FAILED();\n        }\n    }\n\n    // function to free owner from paying cut to bieleivers\n    function freeOwner() public {\n        if (msg.sender != owner) {\n            revert ONLY_ONWER_CAN_CALL_FUNCTION();\n        }\n        if (projectCount < gigCount) {\n            revert JOB_NOT_DONE();\n        }\n\n        // send stake money back to believers\n        if (believers.length >= 1) {\n            for (uint256 i = 0; i < believers.length; i++) {\n                (bool success, ) = believers[i].call{\n                    value: 1e17 / believers.length\n                }(\"\"); // 0.1 Ether\n                if (!success) {\n                    revert TRANSFER_FAILED();\n                }\n            }\n        }\n\n        // empty the array\n        delete believers;\n    }\n\n    // function to get money to platform if the owner cannot able to perform and get gis and complete them\n    function platformGettingPaid() public {\n        if (projectCount > gigCount) {\n            revert JOB_DONE();\n        }\n        // testing\n        if (block.timestamp < contractCreationTime + 10 seconds) {\n            revert STILL_HAVE_TIME();\n        }\n        // production\n        // if(block.timestamp < contractCreationTime + 12 weeks){\n        //     revert STILL_HAVE_TIME();\n        // }\n        (bool success1, ) = platformAddress.call{value: address(this).balance}(\n            \"\"\n        );\n        if (!success1) {\n            revert TRANSFER_FAILED();\n        }\n    }\n\n    // get the balance\n    function getContractBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    // get the length of array\n    function noOfBelievers() public view returns (uint256) {\n        return believers.length;\n    }\n\n    // get the balance of owner\n    function getOwnerBalance() public view returns (uint256) {\n        return owner.balance;\n    }\n\n    // get the balance of 1st beliver\n    function getBeliverBalance() public view returns (uint256) {\n        return believers[0].balance;\n    }\n\n    // Function to receive Ether. msg.data must be empty\n    receive() external payable {}\n\n    // Fallback function is called when msg.data is not empty\n    fallback() external payable {}\n\n    // withdraw the extra fund from smart contract to trust Factory contract\n    function withdraw() public {\n        if (block.timestamp < contractCreationTime + 10 seconds) {\n            revert STILL_HAVE_TIME();\n        }\n\n        (bool success, ) = platformAddress.call{value: address(this).balance}(\n            \"\"\n        );\n        if (!success) {\n            revert TRANSFER_FAILED();\n        }\n    }\n}\n"
    },
    "contracts/TrustFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// contract address : 0x19E8a5A2Eac4B694B67b4Dd510C339184a1888B0\n\npragma solidity ^0.8.14;\n\nimport \"./Trust.sol\";\n\ncontract TrustFactory {\n    // factory contract onwer\n    address private immutable trustFactoryOwner;\n\n    // struct to store all the data of trust and trust factory contract\n    struct trustFactoryStruct {\n        uint256 trustIndex;\n        uint256 percentage;\n        uint256 gigCount;\n        address trustContractAddress;\n        address owner;\n        address platformAddress;\n    }\n\n    // searching the struct data of trust and trust factory using owner/junior address\n    mapping(address => trustFactoryStruct) public allTrustContracts;\n\n    // owner address, onwer address will be used to search the user profile.\n    mapping(address => address) public searchByAddress;\n\n    // number of TrustContracts created\n    uint256 public numOfTrustContracts;\n\n    constructor(address _trustFactoryOwner) {\n        trustFactoryOwner = _trustFactoryOwner;\n    }\n\n    function createTrustContract(uint256 _percentage, uint256 _gigCount)\n        public\n    {\n        // Create a new trust contract\n        Trust trust = new Trust(\n            _percentage,\n            msg.sender,\n            _gigCount,\n            address(this)\n        );\n\n        // Increment the number of Trust contracts\n        numOfTrustContracts++;\n\n        // Add the new trust contract to the mapping\n        allTrustContracts[msg.sender] = (\n            trustFactoryStruct(\n                numOfTrustContracts,\n                _percentage,\n                _gigCount,\n                address(trust),\n                msg.sender,\n                address(this)\n            )\n        );\n\n        // search the profile by using owner address\n        searchByAddress[msg.sender] = address(trust);\n    }\n\n    // get the balance of the contract\n    function getContractBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    // get the address of the contract\n    function getAddressOfContract() public view returns (address) {\n        return address(this);\n    }\n\n    // get the address of trustFactory contract owner\n    function getAddressOfTrustFactoryOnwer() public view returns (address) {\n        return trustFactoryOwner;\n    }\n\n    // Function to receive Ether. msg.data must be empty\n    receive() external payable {}\n\n    // Fallback function is called when msg.data is not empty\n    fallback() external payable {}\n\n    // function to withdraw the fund from contract factory\n    function withdraw(uint256 amount) external payable {\n        if (msg.sender != trustFactoryOwner) {\n            revert ONLY_ONWER_CAN_CALL_FUNCTION();\n        }\n        // sending money to contract owner\n        (bool success, ) = trustFactoryOwner.call{value: amount}(\"\");\n        if (!success) {\n            revert TRANSFER_FAILED();\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}